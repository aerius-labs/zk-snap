import {
  Poseidon,
  Experimental,
  Signature,
  Field,
  MerkleWitness,
  Struct,
  Nullifier,
  PublicKey,
  Provable,
  Bool,
} from 'o1js';
import { EncryptionPublicKey } from '../utils/PallierZK';

export class UserState extends Struct({
  // nullifier: Nullifier, // removed for demo because wallet does not support creating a nullifier
  encryptionPublicKey: EncryptionPublicKey,
  voterRoot: Field,
  userPublicKey: PublicKey,
  electionID: Field,
  encrypted_vote: Provable.Array(Field, 2),
}) {
  static create(
    // nullifier: Nullifier,
    encryptionPublicKey: EncryptionPublicKey,
    voterRoot: Field,
    userPublicKey: PublicKey,
    electionID: Field,
    encrypted_vote: Field[]
  ) {
    return new UserState({
      // nullifier,
      encryptionPublicKey,
      voterRoot,
      userPublicKey,
      electionID,
      encrypted_vote,
    });
  }
}

export class MyMerkleWitness extends MerkleWitness(8) {}

export const UserCircuit = Experimental.ZkProgram({
  publicInput: UserState,

  methods: {
    generateProof: {
      privateInputs: [
        Signature,
        Provable.Array(Field, 2),
        Field,
        MyMerkleWitness,
      ],

      method(
        userState: UserState,
        userSignature: Signature,
        vote: Field[],
        // voteWeight: Field,
        r_encryption: Field,
        // userBalance: Field,
        merkleProof: MyMerkleWitness
      ) {
        // Check if voteWeight <= userBalance
        // voteWeight.assertLessThanOrEqual(userBalance);

        // Construct merkle leaf
        const merkleLeaf = Poseidon.hash([
          userState.userPublicKey.x,
          // userBalance,
        ]);

        // Verify against merkleRoot using merkleProof
        merkleProof.calculateRoot(merkleLeaf).assertEquals(userState.voterRoot);

        // Encrypt vote and verify against input
        for (let i = 0; i < 2; i++) {
          const encryptedVote = userState.encryptionPublicKey.encrypt(
            vote[i],
            r_encryption
          );
          encryptedVote.assertEquals(userState.encrypted_vote[i]);
        }

        // Check if userSignature is generated by userPrivateKey
        userSignature.verify(userState.userPublicKey, [
          userState.userPublicKey.x,
          userState.electionID,
        ]);

        // Verify the nullifier
        // userState.nullifier.verify([
        //   userState.userPublicKey.x,
        //   userState.electionID,
        // ]);
      },
    },
  },
});
